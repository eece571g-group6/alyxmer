// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "@openibc/contracts/libs/Ibc.sol";
import {Dispatcher} from "@openibc/contracts/core/Dispatcher.sol";
import {IbcEventsEmitter} from "@openibc/contracts/interfaces/IbcDispatcher.sol";
import {IbcReceiver} from "@openibc/contracts/interfaces/IbcReceiver.sol";
import "@openibc/contracts/core/UniversalChannelHandler.sol";
import "@openibc/contracts/core/OpConsensusStateManager.sol";
import "@openibc/test/Dispatcher.base.t.sol";
import "./VirtualChain.sol";

import "../contracts/DAONFT.sol";

struct UcPacket {
    bytes32 channelId;
    address srcPortId;
    bytes appData;
}

contract UniversalChannelPacketTest is Base, IbcMwEventsEmitter {
    VirtualChain eth1;
    VirtualChain eth2;
    VirtualChainData v1;
    VirtualChainData v2;

    address receiver;
    bytes appData;
    bytes packetData;
    bytes ackPacketBytes;
    // AckPacket generated by chainB.daonft and received by chainA.daonft
    AckPacket ackPacket;
    // UniversalPacket sent by chainA.daonft and received by chainB.daonft
    UniversalPacket ucPacket;
    // IBC packet received by chainB.Dispatcher
    IbcPacket recvPacket;

    // universal channel packet stored in daonft for test assertion
    UniversalPacket gotUcPacket;
    // ack packet stored in daonft for test assertion
    AckPacket gotAckPacket;
    // channelId stored in daonft for test assertion
    bytes32 gotChannelId;

    function setUp() public virtual override {
        ChannelSetting memory setting = ChannelSetting(
            ChannelOrder.UNORDERED,
            "1.0",
            "polyibc.eth1.7E5F4552091A69125d5DfCb7b8C2659029395Bdf",
            IbcUtils.toBytes32("channel-0"),
            true,
            validProof
        );
        eth1 = new VirtualChain(100, "polyibc.eth1.");
        eth2 = new VirtualChain(200, "polyibc.eth2.");
        eth1.finishHandshake(eth1.ucHandler(), eth2, eth2.ucHandler(), setting);
        v1 = eth1.getVirtualChainData();
        v2 = eth2.getVirtualChainData();
    }

    // test address/bytes32 conversion
    function test_address_conversion() public {
        assertEq(
            address(eth1),
            IbcUtils.toAddress(IbcUtils.toBytes32(address(eth1)))
        );
        assertEq(
            address(eth2),
            IbcUtils.toAddress(IbcUtils.toBytes32(address(eth2)))
        );
    }

    // packet flow: daonft -> UC -> Dispatcher -> (Relayer) -> Dispatcher -> UC -> daonft
    function test_packetFlow_via_universal_channel_ok() public {
        uint256 mwBitmap = v1.ucHandler.MW_ID();
        verifyPacketFlow(5, mwBitmap);
    }

    /**
     * Test packet flow from chain A to chain B via UniversalChannel MW and optionally other MW that sits on top of
     * UniversalChannel MW.
     * @param numOfPackets packet sequence starts from 1, and ends at numOfPackets
     * @param mwBitmap bit OR of all MW_IDs of all MWs in the packet flow
     */
    function verifyPacketFlow(uint64 numOfPackets, uint256 mwBitmap) internal {
        // universal channelIDs
        bytes32 channelId1 = eth1.channelIds(
            address(eth1.ucHandler()),
            address(eth2.ucHandler())
        );
        bytes32 channelId2 = eth2.channelIds(
            address(eth2.ucHandler()),
            address(eth1.ucHandler())
        );
        GeneralMiddleware[2] memory senderMws = [v1.mw1, v1.mw2];
        GeneralMiddleware[2] memory recvMws = [v2.mw2, v1.mw1];

        for (uint64 packetSeq = 1; packetSeq <= numOfPackets; packetSeq++) {
            uint64 timeout = 1 days * 10 ** 9 * packetSeq; // change packet settings for each iteration

            receiver = address(uint160(packetSeq));
            appData = abi.encodePacked(receiver, uint256(packetSeq));

            ucPacket = UniversalPacket(
                IbcUtils.toBytes32(address(v1.daonft)),
                mwBitmap,
                IbcUtils.toBytes32(address(v2.daonft)),
                appData
            );
            packetData = IbcUtils.toUniversalPacketBytes(ucPacket);

            // iterate over sending middleware contracts to verify each MW has witnessed the packet
            for (uint256 i = 0; i < senderMws.length; i++) {
                if (senderMws[i].MW_ID() == (senderMws[i].MW_ID() & mwBitmap)) {
                    vm.expectEmit(true, true, true, true);
                    emit SendMWPacket(
                        channelId1,
                        IbcUtils.toBytes32(address(v1.daonft)),
                        IbcUtils.toBytes32(address(v2.daonft)),
                        senderMws[i].MW_ID(),
                        appData,
                        timeout,
                        abi.encodePacked(senderMws[i].MW_ID())
                    );
                }
            }
            // Mint NFT from Contract
            uint256 tokenId = v1.daonft.mint();
            assertEq(tokenId, uint256(packetSeq));

            // Verify event emitted by Dispatcher
            vm.expectEmit(true, true, true, true);
            emit SendPacket(
                address(v1.ucHandler),
                channelId1,
                packetData,
                packetSeq,
                timeout
            );
            v1.daonft.sendPacket(
                receiver,
                address(v2.daonft),
                channelId1,
                tokenId,
                timeout
            );

            // simulate relayer calling dispatcher.recvPacket on chain B
            // recvPacket is an IBC packet
            recvPacket = IbcPacket(
                IbcEndpoint(eth1.portIds(address(v1.ucHandler)), channelId1),
                IbcEndpoint(eth2.portIds(address(v2.ucHandler)), channelId2),
                packetSeq,
                packetData,
                Height(0, 0),
                timeout
            );

            ackPacket = v2.daonft.generateAckPacket(
                channelId2,
                address(v1.daonft),
                appData
            );
            // verify event emitted by Dispatcher
            vm.expectEmit(true, true, true, true);
            emit RecvPacket(address(v2.ucHandler), channelId2, packetSeq);
            // iterate over receiving middleware contracts to verify each MW has witnessed the packet
            for (uint256 i = 0; i < recvMws.length; i++) {
                if (recvMws[i].MW_ID() == (recvMws[i].MW_ID() & mwBitmap)) {
                    vm.expectEmit(true, true, true, true);
                    emit RecvMWPacket(
                        channelId2,
                        IbcUtils.toBytes32(address(v1.daonft)),
                        IbcUtils.toBytes32(address(v2.daonft)),
                        recvMws[i].MW_ID(),
                        appData,
                        abi.encodePacked(recvMws[i].MW_ID())
                    );
                }
            }
            // verify event emitted by Dispatcher
            vm.expectEmit(true, true, true, true);
            emit WriteAckPacket(
                address(v2.ucHandler),
                channelId2,
                packetSeq,
                ackPacket
            );
            v2.dispatcher.recvPacket(v2.ucHandler, recvPacket, validProof);

            // verify NFT was minted from v2 with the same tokenId
            address v2Receiver = v2.daonft.ownerOf(tokenId);
            assertEq(v2Receiver, receiver);

            // verify packet received by daonft on chain B
            (gotChannelId, gotUcPacket) = v2.daonft.recvedPackets(
                packetSeq - 1
            );
            assertEq(gotChannelId, channelId2);
            assertEq(abi.encode(gotUcPacket), abi.encode(ucPacket));

            //
            // simulate relayer calling dispatcher.acknowledgePacket on chain A
            //

            // iterate over sending middleware contracts to verify each MW has witnessed the ack
            for (uint256 j = 0; j < senderMws.length; j++) {
                // order is reversed than the sending path. Now chain A receives ack from chain B
                uint256 i = senderMws.length - j - 1;
                if (senderMws[i].MW_ID() == (senderMws[i].MW_ID() & mwBitmap)) {
                    vm.expectEmit(true, true, true, true);
                    emit RecvMWAck(
                        channelId1,
                        IbcUtils.toBytes32(address(v1.daonft)),
                        IbcUtils.toBytes32(address(v2.daonft)),
                        senderMws[i].MW_ID(),
                        appData,
                        abi.encodePacked(senderMws[i].MW_ID()),
                        ackPacket
                    );
                }
            }
            // verify event emitted by Dispatcher
            vm.expectEmit(true, true, true, true);
            emit Acknowledgement(address(v1.ucHandler), channelId1, packetSeq);
            // receive ack on chain A, triggering expected events
            v1.dispatcher.acknowledgement(
                v1.ucHandler,
                recvPacket,
                ackToBytes(ackPacket),
                validProof
            );

            // verify ack packet received by daonft on chain A
            (gotChannelId, gotUcPacket, gotAckPacket) = v1.daonft.ackPackets(
                packetSeq - 1
            );
            assertEq(gotChannelId, channelId1);
            assertEq(abi.encode(gotUcPacket), abi.encode(ucPacket));
            assertEq(abi.encode(gotAckPacket), abi.encode(ackPacket));
        }
    }
}
